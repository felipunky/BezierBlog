<html>
<head>
    <title>Bézier Curves</title>
    <link rel="stylesheet"
          type="text/css"
          href="StyleSheet.scss" />
</head>
<body>
    <div id="container"></div>
    <script src="three.min.js"></script>
    <script src="dat.gui.min.js"></script>
    <script id="vertexShader" type="x-shader/x-vertex">
        void main() {
        gl_Position = vec4( position, 1.0 );
        }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">

        uniform vec2 iResolution;
        uniform float iTime;
        uniform vec2 iMouse;
        uniform int iDegree;
        uniform int iIterations;

        // By Felipe Gutierrez,

        float lerp( float a, float b, float t )
        {

        return mix( a, b, t );

        }

        vec2 lerp( vec2 a, vec2 b, float t )
        {

        return mix( a, b, t );

        }

        float quad( float P0, float P1, float P2, float W0, float W1, float W2, float t )
        {

        float ber = 1.0 - t, berO = t * t;

        return ( ber * ber * W0 * P0                 +
        2.0 * ( t * P1 * W1 ) * ber           +
        berO * P2 * W2 ) /
        ( ber * ber * W0                      +
        2.0 * ( t * W1 ) * ber                +
        berO * W2 );

        }

        vec2 quad( vec2 P0, vec2 P1, vec2 P2, float W0, float W1, float W2, float t )
        {

        return vec2( quad( P0.x, P1.x, P2.x, W0, W1, W2, t ),
        quad( P0.y, P1.y, P2.y, W0, W1, W2, t )
        );

        }

        float cub( float P0, float P1, float P2, float P3, float W0, float W1, float W2, float W3,
        float t )
        {

        float ber = 1.0 - t, berO = t * t;

        return ( pow( ber, 3.0 ) * P0 * W0           +
        3.0 * ( ber * ber ) * t * P1 * W1   +
        3.0 * ( ber ) * berO * P2 * W2      +
        pow( t, 3.0 ) * P3 * W3
        ) /
        ( pow( ber, 3.0 ) * W0                +
        3.0 * ( ber * ber ) * t * W1        +
        3.0 * ( ber ) * berO * W2           +
        pow( t, 3.0 ) * W3
        ) ;

        }

        vec2 cub( vec2 P0, vec2 P1, vec2 P2, vec2 P3, float W0, float W1, float W2, float W3, float t )
        {

        return vec2( cub( P0.x, P1.x, P2.x, P3.x, W0, W1, W2, W3, t ),
        cub( P0.y, P1.y, P2.y, P3.y, W0, W1, W2, W3, t )
        );

        }

        float cir( vec2 uv, float r, float b )
        {

        return smoothstep( r, r - b, length( uv ) );

        }

        void main()
        {

        vec2 uv = gl_FragCoord.xy / iResolution.y;
        vec2 mou = iMouse.xy / iResolution.y;

        mou = iMouse.x < 0.1 ? vec2( 1.3, 0.2 ) : mou;

        // r = size of interpolation, rO = size of points.
        float r = 0.007, rO = 0.015, b = 0.02, bO = 0.005;

        vec3 col = vec3( 0 );

        // Points coordinates:
        vec2 A = uv - vec2( 0.1, 0.5 );
        vec2 B = uv - vec2( 0.5, 0.9 );
        vec2 C = uv - mou;
        vec2 D = uv - vec2( 1.7, 0.5 );

        // Weights for the Bézier. This allows us to get perfect Conic Sections from
        // Bézier Curves.
        float w0 = 1.0, w1 = 1.0, w2 = 1.0, w3 = 1.0;

        // Notice the relation for the for loop:
        //                                       if the exit condition is 10,
        //                                       the multiplication of i is 0.1
        // And yes Fabrice I know I can loop on floats :)
        // Iteration exit condition and multiplier.
        if( iIterations == 100 )
        {

            const int n = 100;
            const float m = 0.01;
            for( int i = 0; i < n; ++i )
            {

                if( iDegree == 2 )
                col += cir( lerp( A, C, float( i ) * m ), r, b );
                else if( iDegree == 3 )
                col += cir( quad( A, C, D, w0, w1, w2, float( i ) * m ), r, b );
                else if( iDegree == 4 )
                col += cir( cub( A, B, C, D, w0, w1, w2, w3, float( i ) * m ), r, b );

            }

        }

        if( iIterations == 200 )
        {

            const int n = 200;
            const float m = 0.005;
            for( int i = 0; i < n; ++i )
            {

                if( iDegree == 2 )
                col += cir( lerp( A, C, float( i ) * m ), r, b );
                else if( iDegree == 3 )
                col += cir( quad( A, C, D, w0, w1, w2, float( i ) * m ), r, b );
                else if( iDegree == 4 )
                col += cir( cub( A, B, C, D, w0, w1, w2, w3, float( i ) * m ), r, b );

            }

        }

        if( iIterations == 300 )
        {

            const int n = 300;
            const float m = 0.00333;
            for( int i = 0; i < n; ++i )
            {

                if( iDegree == 2 )
                col += cir( lerp( A, C, float( i ) * m ), r, b );
                else if( iDegree == 3 )
                col += cir( quad( A, C, D, w0, w1, w2, float( i ) * m ), r, b );
                else if( iDegree == 4 )
                col += cir( cub( A, B, C, D, w0, w1, w2, w3, float( i ) * m ), r, b );

            }

        }

        if( iIterations == 400 )
        {

            const int n = 400;
            const float m = 0.0025;
            for( int i = 0; i < n; ++i )
            {

                if( iDegree == 2 )
                col += cir( lerp( A, C, float( i ) * m ), r, b );
                else if( iDegree == 3 )
                col += cir( quad( A, C, D, w0, w1, w2, float( i ) * m ), r, b );
                else if( iDegree == 4 )
                col += cir( cub( A, B, C, D, w0, w1, w2, w3, float( i ) * m ), r, b );

            }

        }

        if( iIterations == 500 )
        {

            const int n = 500;
            const float m = 0.002;
            for( int i = 0; i < n; ++i )
            {

                if( iDegree == 2 )
                col += cir( lerp( A, C, float( i ) * m ), r, b );
                else if( iDegree == 3 )
                col += cir( quad( A, C, D, w0, w1, w2, float( i ) * m ), r, b );
                else if( iDegree == 4 )
                col += cir( cub( A, B, C, D, w0, w1, w2, w3, float( i ) * m ), r, b );

            }

        }

        // Visualizing time t parameter of the basis-functions ( we have to reparametrize our t from 0 to 1, so + 0.5 amplitude and * 0.5):
        float t = 0.5 + sin( iTime * 0.5 ) * 0.5;

        if( iDegree == 2 )
        {

        // PointA.
        col += cir( A, rO, bO ) * vec3( 1, 0, 0 );

        // PointC.
        col += cir( C, rO, bO ) * vec3( 0, 0, 1 );

        // PointT.
        col += cir( lerp( A, C, t ), rO, bO ) * vec3( 1, 1, 0 );

        }

        if( iDegree == 3 )
        {

        // PointA.
        col += cir( A, rO, bO ) * vec3( 1, 0, 0 );

        // PointC.
        col += cir( C, rO, bO ) * vec3( 0, 0, 1 );

        // PointD.
        col += cir( D, rO, bO ) * vec3( 0, 1, 1 );

        // PointT.
        col += cir( quad( A, C, D, w0, w1, w2, t ), rO, bO ) * vec3( 1, 1, 0 );

        }

        if( iDegree == 4 )
        {

        // PointA.
        col += cir( A, rO, bO ) * vec3( 1, 0, 0 );

        // PointB.
        col += cir( B, rO, bO ) * vec3( 0, 1, 0 );

        // PointC.
        col += cir( C, rO, bO ) * vec3( 0, 0, 1 );

        // PointD.
        col += cir( D, rO, bO ) * vec3( 0, 1, 1 );

        // PointT.
        col += cir( cub( A, B, C, D, w0, w1, w2, w3, t ), rO, bO ) * vec3( 1, 1, 0 );

        }

        gl_FragColor = vec4( col, 1.0 );

        }

    </script>

    <script>

        var container;
        var camera, scene, renderer;
        var uniforms;

        init();
        addGUI();
        animate();

        function init() {

            container = document.getElementById('container');

            camera = new THREE.Camera();
            camera.position.z = 1;

            scene = new THREE.Scene();

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            var geometry = new THREE.PlaneBufferGeometry(2, 2);

            uniforms = {
                iTime: { type: "f", value: 1.0 },
                iResolution: { type: "v2", value: new THREE.Vector2() },
                iMouse: { type: "v2", value: new THREE.Vector2() },
                iDegree: { type: "i", value: 3 },
                iIterations: { type: "i", value: 100 }
            };

            var material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent
            });

            var mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            onWindowResize();
            window.addEventListener('resize', onWindowResize, false);

            document.onmousemove = function (e) {
                uniforms.iMouse.value.x = e.pageX;
                uniforms.iMouse.value.y = window.innerHeight / 2 - e.pageY;
            }

        }


        function onWindowResize(event) {

            renderer.setSize(window.innerWidth, window.innerHeight / 2);
            uniforms.iResolution.value.x = renderer.domElement.width;
            uniforms.iResolution.value.y = renderer.domElement.height;

        }

        function animate() {

            requestAnimationFrame(animate);
            render();

        }

        function render() {

            uniforms.iTime.value += 0.05;
            renderer.render(scene, camera);

        }

        function addGUI()
        {

            const gui = new dat.GUI();

            gui.add(uniforms.iDegree, "value", 2, 4, 1).name( "Degree" );
            gui.add(uniforms.iIterations, 'value', 100, 500, 100).name( "Iterations" );

        }

    </script>

</body>

</html>